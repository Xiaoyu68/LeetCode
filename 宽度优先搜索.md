## 宽度优先搜索

BFS使用场景：

1. 连通块问题： 通过一个点找到图中连通的所有点，非递归的方式找到所有方案
2. 分层遍历：图的层次遍历，简单图的最短路径
3. 拓扑排序：求任意拓扑序，求是否有拓扑序，求字典序最小的拓扑序，求是否唯一拓扑序

连通性问题会涉及到并查集和BFS

问最短路径可能：BFS，复杂度： 狄杰斯特拉，Floydm Bellman-ford, SPFA（可以一学）

问最长路径：BFS不能做；如果图可以分层：动归；如果图不可以分层：DFS； 分层的意思是：路径有一定方向性，不能绕圈；第i层的点只能走到第i+1不能回到第i-1层

哈希表：图中存在环，同一个节点可能重复进入队列。用hashset/hashmap记录

java的队列建议 new ArrayDeque不建议new LinkedList(链表比数组慢) （关系不大)

BFS算法的通用模版

```java
Queue<Node> queue = new ArrayDeque<>();
HashMap<Node, Integer> distance = new HashMap<>();

queue.offer(node);
distance.put(node, 0);

while (!queue.isEmpty) {
  Node node = queue.poll();
  
  for (Node neighbor: node.getNeighbors()) {
    if (distance.containsKey(neighbor)) {
      continue;
    }
    distance.put(neighbor, distance.get(node) + 1);
    queue.offer(neighbor);
  }
}
```

substring的时间复杂度是O(n)

字符串相加也是O(n)

看hashset有无元素是O(n), n是字符串的长度；如果是整数是O(1)

找所有点的话不需要回溯，找所有路径需要

DFS进行点的寻找，会有可能产生stack overflow；所以一般要用BFS



