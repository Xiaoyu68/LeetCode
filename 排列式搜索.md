## 排列式搜索

组合是2的n次方个，排列是n的阶乘

```java
public List<List<Integer>> permute(int[] nums) {
  List<List<Integer>> results = new ArrayList<>();
  if (nums == null) {
    return results;
  }
  
  dfs(nums, new boolean[nums.length], new ArrayList<Integer>(permutation));
  return results;
}

private void dfs(int[] nums, boolean[] visited, List<Integer> permutation, List<List<Integer>> results) {
  if (nums.length == permutation.size()) {
    results.add(new ArrayList<Integer>(permutation)); //这个地方是深拷贝
    return;
  }
  
  for (int i = 0; i < nums.length; i++) {
    if (visited[i]) {
      continue;
    }
    
    permutation.add(nums[i]);
    visited[i] = true;
    dfs(nums, visited, permutation, results);
    visited[i] = false;
    permutation.remove(permutation.size() - 1);
  }
}
```

所以时间复杂度是（O(N!*N)

组合类的话 o(2^n * n)

TSP问题

五种解法：

- 暴力DFS
- 暴力DFS和最优性剪枝 optimal prunning
- 状态压缩 state compression dynamic programming
- 随机化算法 randomlization

```java
//暴力dfs
private int minCost(int n, int[][] roads) {
  int[][] graph = constructGraph(roads, n);
  Set<Integer> visited = new HashSet<>();
  Result result = new Result();
  visited.add(1);
  
  dfs(1, n, visited, 0, graph, result);
}
void dfs(int city, int n, Set<Integer> visited, int cost, int[][] graph, Result result) {
  if (visited.size() == n) {
    result.minCost = Math.min(result.minCost, cost);
    return;
  }
  
  for (int i = 1; i < graph[city].length; i++) {
    if (visited.contains(i)) {
      continue;
    }
    visited.add(i);
    
    dfs(i, n, visited, cost + graph[city][i], graph, result);
    
    visited.remove(i);
    
  }
}

int[][] constructGraph(int[][] roads, int n) {
  int[][] graph = new int[n + 1][n + 1];
  for (int i = 0; i < n + 1; i++) {
    for (itn j = 0; j < n + 1; j++) {
      graph[i][j] = Integer.MAX_VALUE >> 4;
    }
  }
  
  for (int i = 0; i < roads.length; i++) {
    int a = roads[i][0];
    int b = roads[i][1];
    int c = roads[i][2];
    
    graph[a][b] = Math.min(graph[a][b], c);
    graph[b][a] = Math.min(graph[b][a], c);
  }
  return graph;
}

//剪枝
private int minCost(int n, int[][] roads) {
  int[][] graph = constructGraph(roads, n);
  Set<Integer> visited = new HashSet<>();
  List<Integer> path = new ArrayList<>();
  Result result = new Result();
  path.add(1)
  visited.add(1);
  
  dfs(1, n, visited, path 0, graph, result);
}
void dfs(int city, int n, Set<Integer> visited, List<Integer> path, int cost, int[][] graph, Result result) {
  if (visited.size() == n) {
    result.minCost = Math.min(result.minCost, cost);
    return;
  }
  
  for (int i = 1; i < graph[city].length; i++) {
    if (visited.contains(i)) {
      continue;
    }
    
    if (hasBetterPath(graph, path, i)) {
      continue;
    }
    visited.add(i);
    path.add(i);
    dfs(i, n, visited, cost + graph[city][i], graph, result);
    
    visited.remove(i);
    path.remove();
    
  }
}

boolean hasBetterPath(int[][] graph, List<Integer> path, int city) {
  for (int i = 1; i < path.size(); i++) {
    int A = path.get(i - 1);
    int B = path.get(i);
    int last = path.get(path.size() - 1);
    
    if (graph[A][B] + graph[last][city] > graph[A][last] + graph[B][city]) {
      return true;
    }
  }
}

int[][] constructGraph(int[][] roads, int n) {
  int[][] graph = new int[n + 1][n + 1];
  for (int i = 0; i < n + 1; i++) {
    for (itn j = 0; j < n + 1; j++) {
      graph[i][j] = Integer.MAX_VALUE >> 4;
    }
  }
  
  for (int i = 0; i < roads.length; i++) {
    int a = roads[i][0];
    int b = roads[i][1];
    int c = roads[i][2];
    
    graph[a][b] = Math.min(graph[a][b], c);
    graph[b][a] = Math.min(graph[b][a], c);
  }
  return graph;
}

//状态压缩 o(2^n * n^2)

public int minCost(int n, int[][] roads) {
  int[][] graph = constructGraph(roads, n);
  int stateSize = 1 << n;
  int[][] dp = new int[stateSize][n + 1];
  for (int i = 0; i < stateSize, i++) {
    for (int j = 0; j < n + 1; j++) {
      dp[i][j] = Integer.MAX_VALUE >> 4;
    }
  }
  
  dp[1][1] = 0;
  for (int state = 0; i < stateSize; i++) {
    for (int i = 2; i < n + 1; i++) {
      
      if ((state & (1 << (i - 1))) == 0) {
        continue;
      }
      int preState = state ^ (1 << (i - 1));
      for (int j = 1; j < n + 1; j++) {
        if ((preState & (1 << (j - 1))) == 0) {
          continue;
        }
        
        dp[state][i] = Math.min(dp[state][i], dp[preState][j] + graph[i][j]);
      }
    }
  }
  int minCost = Integer.MAX_VALUE;
  for (int i = 0; i < n +1; i++) {
    minCost = Math.min(minCost, dp[stateSize - 1][i]);
  }
  return minCost;
}

int[][] constructGraph(int[][] roads, int n) {
  int[][] graph = new int[n + 1][n + 1];
  for (int i = 0; i < n + 1; i++) {
    for (itn j = 0; j < n + 1; j++) {
      graph[i][j] = Integer.MAX_VALUE >> 4;
    }
  }
  
  for (int i = 0; i < roads.length; i++) {
    int a = roads[i][0];
    int b = roads[i][1];
    int c = roads[i][2];
    
    graph[a][b] = Math.min(graph[a][b], c);
    graph[b][a] = Math.min(graph[b][a], c);
  }
  return graph;
}
```

